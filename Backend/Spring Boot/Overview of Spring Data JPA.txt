https://www.pluralsight.com/courses/spring-data-jpa-getting-started

Spring Data

	Spring Data’s mission is to provide a familiar and consistent, Spring-based programming model for data access while still retaining the special traits of the underlying data store.

	It makes it easy to use data access technologies, relational and non-relational databases, map-reduce frameworks, and cloud-based data services. This is an umbrella project which contains many subprojects that are specific to a given database.

Main modules

	Spring Data Commons - Core Spring concepts underpinning every Spring Data module.

	Spring Data JDBC - Spring Data repository support for JDBC.

	Spring Data JDBC Ext - Support for database specific extensions to standard JDBC including support for Oracle RAC fast connection failover, AQ JMS support and support for using advanced data types.

	Spring Data JPA - Spring Data repository support for JPA.

	Spring Data KeyValue - Map based repositories and SPIs to easily build a Spring Data module for key-value stores.

	Spring Data LDAP - Spring Data repository support for Spring LDAP.

	Spring Data MongoDB - Spring based, object-document support and repositories for MongoDB.

	Spring Data Redis - Easy configuration and access to Redis from Spring applications.

	Spring Data REST - Exports Spring Data repositories as hypermedia-driven RESTful resources.

	Spring Data for Apache Cassandra - Easy configuration and access to Apache Cassandra or large scale, highly available, data oriented Spring applications.

	Spring Data for Apache Geode - Easy configuration and access to Apache Geode for highly consistent, low latency, data oriented Spring applications.

	Spring Data for Pivotal GemFire - Easy configuration and access to Pivotal GemFire for your highly consistent, low latency/high through-put, data-oriented Spring applications.

What Is JDBC

	JDBC is a programming-level interface for Java applications that communicate with a database. An application uses this API to communicate with a JDBC manager. It's the common API that our application code uses to communicate with the database. Beyond the API is the vendor-supplied, JDBC-compliant driver for the database we're using.


What Is JPA

	JPA is a Java standard that allows us to bind Java objects to records in a relational database. It's one possible approach to Object Relationship Mapping(ORM), allowing the developer to retrieve, store, update, and delete data in a relational database using Java objects. Several implementations are available for the JPA specification.

Spring Data JPA

	Nowadays, Spring Framework has become more and more popular especially in building applications for enterprises. Of course, enterprise applications have to work with data such as querying, storing, and updating the data. Unfortunately, working on the data layer with no framework supporting is the hard part, we have to prevent boilerplate code, do sorting, paging, or even build methods to query common situations like writing SQL query statements when we need to query data from a table. With Spring Data JPA, these things will become the pass.

Let take at the name of ‘Spring Data JPA’.
	‘Spring’ means it is a part of the Spring Data family.
	“Data” is means support working with data.
	And ‘JPA’ means that it follows the Java Persistence API.

Database Interactions

	JDBC allows us to write SQL commands to read data from and update data to a relational database. JPA, unlike JDBC, allows developers to construct database-driven Java programs utilizing object-oriented semantics. The JPA annotations describe how a given Java class and its variables map to a given table and its columns in a database.

	The JPA framework then handles all the time-consuming, error-prone coding required to convert between object-oriented Java code and the back-end database.

Managing Associations

	When associating database tables in a query with JDBC, we need to write out the full SQL query, while with JPA, we simply use annotations to create one-to-one, one-to-many, many-to-one, and many-to-many associations.

Database Dependency

	JDBC is database-dependent, which means that different scripts must be written for different databases. On the other side, JPA is database-agnostic, meaning that the same code can be used in a variety of databases with few (or no) modifications.

	JPA-based applications still use JDBC under the hood. Therefore, when we utilize JPA, our code is actually using the JDBC APIs for all database interactions. In other words, JPA serves as a layer of abstraction that hides the low-level JDBC calls from the developer, making database programming considerably easier.

Exception Handling

	Because JDBC throws checked exceptions, such as SQLException, we must write it in a try-catch block. On the other hand, the JPA framework uses only unchecked exceptions, like Hibernate. Hence, we don't need to catch or declare them at every place we're using them.

Transaction Management

	In JDBC, transaction management is handled explicitly by using commit and rollback. On the other hand, transaction management is implicitly provided in JPA.

Pros and Cons

	The most obvious benefit of JDBC over JPA is that it's simpler to understand. On the other side, if a developer doesn't grasp the internal workings of the JPA framework or database design, they will be unable to write good code.

	Also, JPA is thought to be better suited for more sophisticated applications by many developers. But, JDBC is considered the preferable alternative if an application will use a simple database and we don't plan to migrate it to a different database vendor.

	The main advantage of JPA over JDBC for developers is that they can code their Java applications using object-oriented principles and best practices without having to worry about database semantics. As a result, development can be completed more quickly, especially when software developers lack a solid understanding of SQL and relational databases.

	Also, because a well-tested and robust framework is handling the interaction between the database and the Java application, we should see a decrease in errors from the database mapping layer when using JPA.

Spring Data JPA and Hibernate

What is the difference between Spring Data JPA and Hibernate.

	Before we jump to the difference, You have to understand that JPA is a specification so we still need a provider to get JPA 	actually works. 
	Hibernate, EclipseLink and OpenJPA is the most popular provider which implement JPA specification. 
	Hibernate and EclipseLink are similar to Oracle JDK and OpenJDK. 
	One more example is the interface(JPA) and implemented classes(Hibernate, EclipseLink, OpenJPA).
	Spring Data JPA provides an abstract data access layer that has some generic method to accession data follow the convention.

Reduce boilerplate code.
	
	Spring Data JPA was designed to help us reduce boilerplate code very very well. It has defined generic repositories so we no longer need to write implement for basic actions.

Few features provided by Spring Data JPA are:

	Create and support repositories created with Spring and JPA
	Support QueryDSL and JPA queries
	Audit of domain classes
	Support for batch loading, sorting, dynamical queries
	Supports XML mapping for entities
	Reduce code size for generic CRUD operations by using CrudRepository

Entity

	Entities in JPA are nothing but POJOs representing data that can be persisted to the database. An entity represents a table stored in a database. Every instance of an entity represents a row in the table.

	The entity name defaults to the name of the class. We can change its name using the name element.

The Id Annotation

	Each JPA entity must have a primary key which uniquely identifies it. The @Id annotation defines the primary key. We can generate the identifiers in different ways which are specified by the @GeneratedValue annotation.

	We can choose from four id generation strategies with the strategy element. The value can be AUTO, TABLE, SEQUENCE, or IDENTITY.

	If we specify GenerationType.AUTO, the JPA provider will use any strategy it wants to generate the identifiers.

The Table Annotation

	In most cases, the name of the table in the database and the name of the entity will not be the same.

	In these cases, we can specify the table name using the @Table annotation

	We can also mention the schema using the schema element:

	If we do not use the @Table annotation, the name of the entity will be considered the name of the table.

The Column Annotation

	Just like the @Table annotation, we can use the @Column annotation to mention the details of a column in the table.

	The @Column annotation has many elements such as name, length, nullable, and unique.

	If we don't specify this annotation, the name of the field will be considered the name of the column in the table.

The Transient Annotation

	Sometimes, we may want to make a field non-persistent. We can use the @Transient annotation to do so. It specifies that the field will not be persisted.

	For instance, we can calculate the age of a student from the date of birth.

	So let's annotate the field age with the @Transient annotation


One-to-one
	This association is represented by @OneToOne annotation. Here, instance of each entity is related to a single instance of another entity.

	In this example, we will create a One-To-One relationship between a Student and Library in such a way that one student can be issued only one type of book.

One-to-many
	
	This association is represented by @OneToMany annotation. In this relationship, an instance of one entity can be related to more than one instance of another entity.

	In this example, we will create a One-To-Many relationship between a Student and Library in such a way that one student can be issued more than one type of book.

Many-to-one 
	
	This mapping is defined by @ManyToOne annotation. In this relationship, multiple instances of an entity can be related to single instance of another entity.

	In this example, we will create a Many-To-One relationship between a Student and Library in such a way that more than one student can issued the same book.

Many-to-many
	
	This association is represented by @ManyToMany annotation. Here, multiple instances of an entity can be related to multiple instances of another entity. In this mapping, any side can be the owing side.

	In this example, we will create a Many-To-Many relationship between a Student and Library in such a way that any number of students can be issued any type of books.